Questions:

    1. (Fixed) Why do we put a minus sign in front of the error code? (getattr() in a1fs.c)
        - It is the convention to return a negated error code

    2. (Fixed) For a1fs_getattr(), what if the path name is root?
        - Use a do while loop to deal with the root inode first.

    3. (Fixed) How should we fill in st->st_mode in a1fs_getattr?
        - Since we dont care about permission in A1, just 'd' & 'f' is enough, or we could just set give every permission like rwxrwxrwx.

    4. (Fixed) Should we really set a1fs_extent.start's type to a1fs_blk_t?
        - The a1fs_extent.start is actually not a pointer to block
          but a block number of the block containing the extent.

    5. (Fixed) Should we initialize all inodes on disk formatting?
        - Each inode would have to be intialized with a extent block to store . and .. directory.
        - Answer:
            - Yes it is possible to allocate inode at run time since the super block keeps track of free inodes count.
#!/bin/bash shebang line   setup compiler   default is ./bin/bash
Notes:

    - Only implement these for struct stat
        struct stat {
            mode_t    st_mode;    /* protection */
            nlink_t   st_nlink;   /* number of hard links */
            off_t     st_size;    /* total size, in bytes */
            blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
            time_t    st_mtime;   /* time of last modification */
        };

    - 256 bytes per dentry, then an directory could contain 8192 dentries at max.

    - How to visit a file/dir from absolute path:
        1. Go to superblock for root inode
        1.5 In root inode, take the dentry_count, go to the corresponding extent
        2. In curr( inode, take the dentry_count, go to the corresponding extent
        3. do a for-loop to search for the dir_name in path
        4. Go to the corresponding inode
        5. repeat 2~4 until all the end of absolute path (NULL)

    -   struct timespec {
           time_t tv_sec;                /* Seconds */
           long   tv_nsec;               /* Nanoseconds */
        };

    - How to read all dentry under an inode?
        1. Go to the first extent
        2. Interate through the directory entries using dentry_count
        3. If there are still some extent left go to 4
        4. go to the next extent block
        5. repeat 2 to 5 until all entries are iterated

    - How to find pid for a process?
        - use pidof <process>, e.g. pidof firefox
    
    - Does creat() create hardlink?
        - yes

    - Are . and .. hard links?
        -yes
Todos:
    - a1fs.c:
        - ( ) Extend step 2 in get_ino_num_by_path
        - (Done) Fill in st->st_mode in a1fs_getattr
    - mkfs.c:
        - (Done) Write bit to bit
            - Reason: asicii code for '0' is 48, thus writing '0' to disk does not work
        - (Done) Initialize the extent for root inode and root directory
            - (Done) But shouldnt root node go with empty extent at initialization?
                - Answer: No, each root inode on intiailization would need at least one extent for the two entry for "." and "..".